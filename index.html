<!DOCTYPE html>
<html lang="en">
    <head>
        <link href="bootstrap/css/bootstrap.css" rel="stylesheet" media="screen">
        <link href="dw.css" rel="stylesheet">

        <script src="http://code.jquery.com/jquery.js"></script>
        <script src="bootstrap/js/bootstrap.js"></script>

        <title>DataWorker</title>
    </head>
    <body>
        <div class="container" id="top">
            <div class="header-row row">
                <div class="span12">
                    <h1>DataWorker</h1>
                </div>
            </div>
            <div class="row">
                <div class="span3">
                    <ul class="nav nav-tabs nav-stacked">
                        <li><a href="#top">DataWorker</a></li>
                        <li class="nav-header">Get started!</li>
                        <li><a href="#construct">Construct</a></li>
                        <li><a href="#stream">Streaming Data</a></li>
                        <li><a href="#clone">Clone</a></li>
                        <li><a href="#child-rows">Child Rows</a></li>
                        <li class="nav-header">Manipulate the dataset!</li>
                        <li><a href="#alter-columns">Alter columns</a></li>
                        <li><a href="#append">Append</a></li>
                        <li><a href="#filter">Filter</a></li>
                        <li><a href="#search">Search</a></li>
                        <li><a href="#group">Group</a></li>
                        <li><a href="#join">Join</a></li>
                        <li><a href="#limit">Limit</a></li>
                        <li><a href="#remove-columns">Remove columns</a></li>
                        <li><a href="#hide-columns">Hide columns</a></li>
                        <li><a href="#clear-dataset">Clear Dataset</a></li>
                        <li><a href="#sort">Sort</a></li>
                        <li><a href="#add-child-rows">Add Child Rows</a></li>
                        <li class="nav-header">Access the dataset!</li>
                        <li><a href="#get-dataset">Get dataset</a></li>
                        <li><a href="#get-rows">Get rows</a></li>
                        <li><a href="#get-hashed-rows">Get hashed rows</a></li>
                        <li><a href="#get-columns">Get columns</a></li>
                        <li><a href="#get-columns-and-records">Get columns and records</a></li>
                        <li><a href="#get-number-of-records">Get number of records</a></li>
                        <li><a href="#get-distinct">Get distinct</a></li>
                        <li><a href="#pagination">Pagination</a></li>
                        <li><a href="#partition">Partition</a></li>
                        <li><a href="#render">Render</a></li>
                    </ul>
                </div>
                <div class="span9">
                    <section id="construct">
                        <h3>Construct</h3>
                        <p>DataWorker takes an array of records to construct the initial dataset. The first record defines column properties.</p>
                        <pre>
    var dataset = [
        [
            {
                name: "column_a",
                title: "Column A",
                aggType: "max",
                sortType: "alpha"
            },
            {
                name: "column_b",
                title: "Column B",
                aggType: "max",
                sortType: "alpha"
            },
            {
                name: "column_c",
                title: "Column C",
                aggType: "min",
                sortType: "alpha"
            }
        ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ];

    var dw = new DataWorker(dataset);</pre>
                        <p>It is also possible to just supply column names:</P>
                        <pre>
    var dataset = [
        [ "column_a", "column_b", "column_c" ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ];

    var dw = new DataWorker(dataset);</pre>
                        <p>If only column names are supplied, the following default column properties are used:</p>
                        <ul>
                            <li><code>title</code>: <code>columnName</code></li>
                            <li><code>aggType</code>: "max"</li>
                            <li><code>sortType</code>: "alpha"</li>
                        </ul>
                        <p>Additionally, you should give DataWorker an error handler (otherwise DataWorker will just fail silently) using the <code>onError</code> method:</p>
                        <pre>
    var dw = new DataWorker(dataset).onError(function (errorMsg) {
        alert(errorMsg);
    });</pre>
                    <h5>Error handling</h5>
                    <p>DataWorker can be provided with an error handler:</p>
                    <pre>
    dw.onError(function (msg) {
        alert(msg);
    });</pre>
                    <p>By default, errors are printed to the console.</p>
                    </section>
                    <section id="stream">
                        <h3>Streaming Data</h3>
                        <h5>Via Websockets</h5>
                        <p>Alternatively, DataWorker can stream data from a WebSocket server:</p>
                        <pre>
    var dw = new DataWorker({
        datasource   : "ws://127.0.0.1:8888",
        authenticate : "{}",
        request      : "{\"cmd\":\"requestDataset\"}"
    });</pre>
                        <p><code>datasource</code> should be the URL of the websocket server.</p>
                        <p><code>authenticate</code> is optional. If present, will be the first message sent to the server upon connecting.</p>
                        <p><code>request</code> is sent after <code>authenticate</code>.<p>
                        <p>After the request is sent, DataWorker will expect a reply in the form of a JSON object with <code>totalNumRows</code> and <code>columns</code> properties such as:</p>
                        <pre>
    {
        totalNumRows : 10,
        columns      : [ "column_a", "column_b", "column_c" ]
    }</pre>
                        <p><code>totalNumRows</code> should be the number of rows to expect in that dataset.</p>
                        <p><code>columns</code> should be the columns of the expected dataset. They can be provided as simple column names or as hashes with custom column properties.</p>
                        <p>Note DataWorker cannot proceed without first knowing the columns and the total number of expected rows. That being said, these two properties may be transmitted separately. For example:</p>
                        <pre>
    // First message:
    { "totalNumRows": 10 }

    // Second message:
    { columns: [ "column_a", "column_b", "column_c" ] }</pre>
                        <p>Afterwards, DataWorker will expect arrays of dataset rows from the server. These rows will be appended to the dataset. The reply will be similar to the following:</p>
                        <pre>
    [
        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ]</pre>
                        <p>The <code>onReceiveRows</code> callback will be called whenever rows are received from the Websocket server. This callback can be set with the <code>onReceiveRows</code> method:</p>
                        <pre>
    dw.onReceiveRows(function (numRows) {
        alert("Received " + numRows + " rows.");
    });</pre>
                        <p>Alternatively, this callback can be passed into the constructor:</p>
                        <pre>
    var dw = new DataWorker({
        datasource    : "ws://127.0.0.1:8888",
        authenticate  : "{}",
        request       : "{\"cmd\":\"requestDataset\"}",
        onReceiveRows : function (numRows) {
            alert(numRows + " rows received.");
        }
    });</pre>
                        <p>If not set, this callback defaults to doing nothing.</p>
                        <p>The <code>onAllRowsReceived</code> callback is called when all expected rows have been received from the Websocket server. This callback can be set with the <code>onAllRowsReceived</code> method:</p>
                        <pre>
    dw.onAllRowsReceived(function () {
        alert("All rows have been received!");
    });</pre>
                        <p>Alternatively, this callback can be passed into the constructor:</p>
                        <pre>
    var dw = new DataWorker({
        datasource         : "ws://127.0.0.1:8888",
        authenticate       : "{}",
        request            : "{\"cmd\":\"requestDataset\"}",
        onReceiveRows      : function (numRows) {
            alert(numRows + " rows received.");
        }
        onAllRowsReceived : function () {
            alert("All rows have been received!");
        }
    });</pre>
                        <p>If not set, this callback does nothing.</p>
                        <h5>Via AJAX</h5>
                        <p>If WebSockets are not available, data can be received via AJAX as well:</p>
                        <pre>
    var dw = new DataWorker({
        datasource           : "http://127.0.0.1:8888",
        request              : "?this=is;a=query;string",
        onAllRowsReceived : function () {
            alert("all rows have been received!");
        }
    });</pre>
                        <p><code>datasource</code> should be the base url to send GET requests to.</p>
                        <p><code>request</code> should be the query string to append to the base url. The prepended question mark is optional; if it is missing, one will automatically be inserted. Optionally, <code>request</code> could be a JSON string; DataWorker will convert this into a query string.</p>
                        <p>The only callback triggered by AJAX datasets is the <code>onAllRowsReceived</code> callback.</p>
                        <h5>Using fallbacks</h5>
                        <p>If multiple data sources exist, it is possible to provide fallbacks when instantiating DataWorker. This can be useful if you have a server down for maintenance or your WebSocket service is not running. Simply provide the possible sources as an array to <code>datasource</code> in priority order:</p>
                        <pre>
    var dw = new DataWorker({
        request    : "{\"cmd\":\"requestDataset\"}",
        datasource : [
            "http://example.com",
            "ws://127.0.0.1:8888",
            "http://127.0.0.1:9999"
        ]
    });</pre>
                        <p>The sources will be tried in order. If they all fail, DataWorker will throw an error.</p>
                        <h5>Requesting further data</h5>
                        <p>A new dataset can be requested using the <code>requestDataset</code> method:</p>
                        <pre>
    // For WebSockets or AJAX:
    dw.requestDataset("{\"cmd\":\"requestDataset\"}");

    // For AJAX only:
    dw.requestDataset("query=string");</pre>
                        <p>The newly-requested dataset will completely replace the previously-requested dataset.</p>
                        <p>A new dataset can be requested and appended to the current dataset using the <code>requestDatasetForAppend</code> method:</p>
                        <pre>
    // For WebSockets or AJAX:
    dw.requestDatasetForAppend("{\"cmd\":\"requestDataset\"}");

    // For AJAX only:
    dw.requestDatasetForAppend("query=string");</pre>
                        <p>Note that the newly-requested dataset should have the same columns as the previously-requested dataset.</p>
                    </section>
                    <section id="clone">
                        <h3>Clone</h3>
                        <p>A DataWorker dataset can be deep-copied by calling <code>clone</code>:</p>
                        <pre>
    dw.clone(function (newD) {
        newDataset = newD;
    });</pre>
                        <p>Note that any streaming datasources are not copied as part of the cloning process.</p>
                    </section>
                    <section id="child-rows">
                        <h3>Child Rows</h3>
                        <p>DataWorker has a concept of child rows. Child rows are rows that are a subset of another row, and may be used, for example, to provide more detail. The functionality is currently limited to a small subset of functions. Where use of child rows is not explicitly defined, they are treated as if they are distinct rows that have been added to the dataset. These are the currently supported functions:</p>
                        <ul>
                            <li><a href="#sort">Sort</a></li>
                            <li><a href="#add-child-rows">Add Child Rows</a></li>
                        </ul>
                    </section>
                    <section id="alter-columns">
                        <h3>Alter columns</h3>
                        <p>Column properties can be altered after DataWorker is instantiated.</p>
                        <h5>Alter column name</h5>
                        <p>To change the name of <code>column_a</code> to <code>column_a1</code>:</p>
                        <pre>
    dw.alterColumnName("column_a", "column_a1");</pre>
                        <h5>Alter column title</h5>
                        <p>To change the title of <code>column_a</code> to <code>Things I Love</code>:</p>
                        <pre>
    dw.alterColumnTitle("column_a", "Things I Love");</pre>
                        <h5>Alter column aggregate type</h5>
                        <p>To change the aggregate type of <code>column_a</code> to <code>min</code>:</p>
                        <pre>
    dw.alterColumnAggregateType("column_a", "min");</pre>
                        <p>Valid aggregate types are:</p>
                        <ul>
                            <li><code>max</code></li>
                            <li><code>min</code></li>
                            <li><code>sum</code></li>
                        </ul>
                        <h5>Alter column sort type</h5>
                        <p>To change the sort type of <code>column_a</code> to <code>num</code>:</p>
                        <pre>
    dw.alterColumnSortType("column_a", "num");</pre>
                        <p>Valid sort types are:</p>
                        <ul>
                            <li><code>alpha</code></li>
                            <li><code>num</code></li>
                        </ul>
                        <p>Alternatively, you may pass in a sort function that takes two arguments <code>(a, b)</code> and returns <code>-1</code> for <code>a &lt b</code>, <code>1</code> for <code> a &gt b</code> or <code>0</code> for <code>a == b</code>.</p>
                        <h5>Prepend column names</h5>
                        <p>To prepend <code>a_</code> to all column names:</p>
                        <pre>
    dw.prependColumnNames("a_");</pre>
                    </section>
                    <section id="append">
                        <h3>Append</h3>
                        <p>The <code>append</code> method is used to concatenate two datasets together. The following appends <code>dataset2</code> to <code>dataset1</code>:</p>
                        <pre>
    var dataset1 = [
        [ "column_a", "column_b", "column_c" ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
    ];
    var dataset2 = [
        [ "column_a", "column_b", "column_c" ],

        [ "gummy",       "power",    "apple" ],
        [ "car",        "screen",    "phone" ],
        [ "sign",        "bagel",    "chips" ]
    ];

    var dw = new DataWorker(dataset1);
    dw.append(dataset2);</pre>
                        <p>Alternatively, you may also append a DataWorker dataset:</p>
                        <pre>
    var dataset1 = [
        [ "column_a", "column_b", "column_c" ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ]
    ];
    var dataset2 = [
        [ "column_a", "column_b", "column_c" ],

        [ "gummy",       "power",    "apple" ],
        [ "car",        "screen",    "phone" ],
        [ "sign",        "bagel",    "chips" ]
    ];

    var d1 = new DataWorker(dataset1);
    var d2 = new DataWorker(dataset2);
    d1.append(d2);</pre>
                        <p>Note that column names must match up; an error will be thrown otherwise.</p>
                    </section>
                    <section id="filter">
                        <h3>Filter</h3>
                        <p>The <code>applyFilter</code> method is used to filter out rows that do not contain the specified regex. The following filters out any row that does not contain the word "apple":</p>
                        <pre>
    var dataset = [
        [ "column_a", "column_b", "column_c"         ],

        [ "apple",    "red",      "fuji"             ],
        [ "apple",    "green",    "granny smith"     ],
        [ "apple",    "yellow",   "golden delicious" ],

        [ "banana",   "green",    "unripe"           ],
        [ "banana",   "yellow",   "ripe"             ],
        [ "banana",   "brown",    "beyond ripe"      ],
        [ "banana",   "black",    "rotten/frozen"    ]
    ], dw = new DataWorker(dataset);

    dw.applyFilter(/\bapple\b/)

    /* This results in the following rows:
        [ "apple", "red",    "fuji"             ],
        [ "apple", "green",  "granny smith"     ],
        [ "apple", "yellow", "golden delicious" ]
    */</pre>
                        <p>You may also filter only on certain columns:</p>
                        <pre>
    dw.applyFilter(/\bapple\b/, "column_a", "column_b");</pre>
                        <p>Note that the following also works (and results in the exact same dataset):</p>
                        <pre>
    dw.applyFilter(/\bapple\b/, [ "column_a", "column_b" ]);</pre>
                        <p>You may also use the complex syntax, in which all filters provided must find a match for the row to be visible. The complex filters can take any of the following arguments:</p>
                        <ul>
                            <li><code>columns</code> <i>(array of strings or single string)</i>: Columns on which to filter (defaults to all columns)</li>
                            <li><code>column</code> <i>(single string)</i>: Single column on which to filter (defaults to all columns) (note: if both <code>columns</code> and <code>column</code> are defined, the latter will be used)</li>
                            <li><code>matchAll</code> <i>(boolean)</i>: If this flag is set to <code>true</code> then all columns provided must match the filter for the row to stay visible. By default, if any of the columns match the row will stay visible</li>
                            <li><code>eq</code> <i>(value)</i>: Columns must equal (==) this value</li>
                            <li><code>ne</code> <i>(value)</i>: Columns must not equal (!=) this value</li>
                            <li><code>gte</code> <i>(value)</i>: Columns must be greater than or equal to (&gt;=) this value</li>
                            <li><code>gt</code> <i>(value)</i>: Columns must be greater than (&gt;) this value</li>
                            <li><code>lte</code> <i>(value)</i>: Columns must be lesser than or equal to (&lt;=) this value</li>
                            <li><code>lt</code> <i>(value)</i>: Columns must be lesser than (&lt;) this value</li>
                        </ul>
                        <p>For example:</p>
                        <pre>
    dw.applyFilter(
        {
            column : "column_a",
            eq     : "apple"
        },
        {
            column : "column_b",
            regex  : /yellow/
        },
        {
            columns : [ "column_a", "column_b" ],
            gte: "apple",
            lt: "zebra"
        }
    );

    /* This results in the single row:
        [ "apple", "yellow", "golden delicious" ]
    */</pre>
                        <p>The filter can be cleared by calling the <code>clearFilters</code> method:</p>
                        <pre>
    dw.clearFilters();</pre>
                        <p>Filters stack on top of each other:</p>
                        <pre>
    dw.applyFilter(/banana/);
    /* This results in the following rows:
        [ "banana", "green",  "unripe"        ],
        [ "banana", "yellow", "ripe"          ],
        [ "banana", "brown",  "beyond ripe"   ],
        [ "banana", "black",  "rotten/frozen" ]
    */

    dw.applyFilter(/yellow/);
    /* The results are further filtered down to one row:
        [ "banana", "yellow", "ripe" ],
    */

    dw.clearFilters().applyFilter(/yellow/);
    /* Old filters are cleared and a new one is applied:
        [ "apple",  "yellow", "golden delicious" ],
        [ "banana", "yellow", "ripe"             ],
    */</pre>
                        <p>To permanently remove rows from a dataset with a filter, use the <code>filter</code> method:</p>
                        <pre>
    dw.filter(/\bapple\b/)</pre>
                    </section>
                    <section id="search">
                        <h3>Search</h3>
                        <p>Similar to filters, the <code>search</code> method filters the currently visible dataset. The difference is that this will not modify the dataset. The simple form takes a callback and a search term, which can be either a regular expression or a string.</p>
                        <pre>
    dw.search(function (results) { console.log(results); }, /apple/);</pre>
                        <p>It's also possible to pass in extra, optional arguments as an object. The valid options are:</p>
                        <ul>
                            <li><code>columns</code> <i>(array of strings or single string)</i>: Columns to be searched and returned (defaults to all columns)</li>
                            <li><code>searchOn</code> <i>(array of strings or single string)</i>: Columns to be searched (defaults to <code>columns</code>, which defaults to all columns)</li>
                            <li><code>returnColumns</code> <i>(array of strings or single string)</i>: Columns to be returned (defaults to <code>columns</code>, which defaults to all columns)</li>
                            <li><code>sortOn</code> <i>(array of strings or single string)</i>: Rows will be sorted on this/these columns, which can be invisible columns</li>
                            <li><code>limit</code> <i>(integer)</i>: Maximum number of rows to return. Data will be sorted before limiting results</li>
                        </ul>
                        <p>For example:</p>
                        <pre>
    dw.search(function (results) { console.log(results); }, /a.*le/i, {
        columns: [ "column_a", "column_c" ],
        sortOn: "-column_b",
        limit: 3
    });</pre>
                    </section>
                    <section id="group">
                        <h3>Group</h3>
                        <p>Similar to grouping in SQL, the <code>group</code> method allows you to group rows together.</p>
                        <pre>
    dw.group("column_a");</pre>
                        <p>You may also group by multiple rows:</p>
                        <pre>
    dw.group("column_a", "column_b");</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>
    dw.group([ "column_a", "column_b" ]);</pre>
                        <p>Rows with the same value for the specified column(s) will be combined; the column property <code>aggType</code> determines how values for non-specified columns are combined.</p>
                    </section>
                    <section id="join">
                        <h3>Join</h3>
                        <p>DataWorker also supports joining via the <code>join</code> method. It can inner join, left outer join, or right outer join.</p>
                        <p>The following inner joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, "column_a", "column_d");</pre>
                        <p>The following left outer joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, "column_a", "column_d", "left");</pre>
                        <p>The following right outer joins <code>d1</code> with <code>d2</code> on <code>column_a</code> from <code>d1</code> and <code>column_d</code> from <code>d2</code>:</p>
                        <pre>
    d1.join(d2, "column_a", "column_d", "right");</pre>
                        <p>Joins can also be performed on multiple columns:</p>
                        <pre>
    d1.join(d2, [ "column_a", "column_b" ], [ "column_d", "column_e" ]);</pre>
                    </section>
                    <section id="limit">
                        <h3>Limit</h3>
                        <p>The <code>applyLimit</code> method limits the amount of visible rows in the dataset. The following allows only the first 10 rows in the dataset to be visible:</p>
                        <pre>   dw.applyLimit(10);</pre>
                        <p>The limit can be cleared by calling the <code>clearFilters</code> method:</p>
                        <pre>   dw.clearFilters();</pre>
                        <p>To permanently remove rows from a dataset with a limit, use the <code>limit</code> method:</p>
                        <pre>   dw.limit(10)</pre>
                    </section>
                    <section id="remove-columns">
                        <h3>Remove columns</h3>
                        <p>You may completely delete columns from a dataset with the <code>removeColumns</code> method.</p>
                        <pre>   dw.removeColumns("column_a", "column_b");</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   dw.removeColumns([ "column_a", "column_b" ]);</pre>
                    </section>
                    <section id="hide-columns">
                        <h3>Hide columns</h3>
                        <p>Instead of permanently deleting the columns, you may also temporarily hide them from view using the <code>hideColumns</code> method:</p>
                        <pre>   dw.hideColumns("column_a", "column_b");</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   dw.hideColumns([ "column_a", "column_b" ]);</pre>
                        <p>Hidden columns can be shown with the <code>showColumns</code> method:</p>
                        <pre>   dw.showColumns("column_a", "column_b");</pre>
                        <p>Note that the following is also valid:</p>
                        <pre>   dw.showColumns([ "column_a", "column_b" ]);</pre>
                        <p>The <code>hideColumns</code> and <code>showColumns</code> methods may also take a regex as an argument. Any column name matching the regex will be hidden/shown, respectively.</p>
                        <pre>   dw.hideColumns(/^column_[ab]$/i);</pre>
                        <p>All columns can be hidden with the <code>hideAllColumns</code> method:</p>
                        <pre>   dw.hideAllColumns();</pre>
                        <p>All hidden columns can be revealed with the <code>showAllColumns</code> method:</p>
                        <pre>   dw.showAllColumns();</pre>
                        <p>Alternatively, you may retrieve all columns (visible AND non-visible) by using the <code>getAllColumns</code> method:</p>
                        <pre>
    dw.getAllColumns(function (columns) {
        allColumns = columns;
    });</pre>
                    </section>
                    <section id="clear-dataset">
                        <h3>Clear Dataset</h3>
                        <p>If you want to completely clear the dataset so that you can add new data while leaving any custom handlers intact, you may call <code>clearDataset</code>.</p>
                        <pre>   dw.clearDataset();</pre>
                        <p>This will remove references to all columns and rows. The function takes no parameters.</p>
                    </section>
                    <section id="sort">
                        <h3>Sort</h3>
                        <p>The following sorts the dataset on <code>column_a</code>:</p>
                        <pre>
    dw.sort("column_a")</pre>
                        <p>To reverse sort, prepend the column name with a <code>-</code>:</p>
                        <pre>
    dw.sort("-column_a")</pre>
                        <p>You may also sort on multiple columns:</p>
                        <pre>
    dw.sort("column_a", "-column_b");</pre>
                        <p>In this case, the sort will fallback to <code>column_b</code> if the contents of <code>column_a</code> are equal.</p>
                        <p>Note that the following does the same thing:</p>
                        <pre>
    dw.sort([ "column_a", "-column_b" ]);</pre>
                        <p>When child rows exist in the dataset, parents and children are kept together. The dataset will be sorted first by the parent, then by the children, using the same column. Using the example from <a href="#add-child-rows">Add Child Rows</a>, <code>dw.sort("-numbers");</code> will produce the following dataset:</p>
                        <pre>
    [
        [ "xyz", 789 ],
            [ "xyz", 789 ],
        [ "abc", 123 ],
            [ "abc", 579 ],
            [ "abc", 456 ],
        [ "def", 0   ]
    ]</pre>
                    </section>
                    <section id="add-child-rows">
                        <h3>Add Child Rows</h3>
                        Child rows can be added to the dataset by calling <code>addChildRows</code>. The columns must be the same as the original dataset as in the following example:</p>
                        <pre>
    var dataset = [
        [ "letters", "numbers" ],

        [ "abc",     579       ],
        [ "def",     0         ],
        [ "xyz",     789       ]
    ], childRows = [
        [ "abc",     123       ],
        [ "abc",     456       ],
        [ "xyz",     789       ]
    ], dw = DataWorker(dataset);</pre>
                        <p>The call to <code>addChildRows</code> expects a column that will be used to determine to which row the children belong. It also expects a dataset of child rows.</p>
                        <p>You may either pass in an array of rows:</p>
                        <pre>
    dw.addChildRows(childRows, "letters");</pre>
                        <p><b>or</b> you may pass in another DataWorker object:</p>
                        <pre>
    var d2 = DataWorker([[ "letters", "numbers" ]].concat(childRows), "letters");

    dw.addChildRows(d2);</pre>
                        <p>In either case, the result passed into the callback for <code>getDataset</code> will be the same:</p>
                        <pre>
    [
        [ "abc", 123 ],
            [ "abc", 456 ],
            [ "abc", 579 ],
        [ "def", 0   ],
        [ "xyz", 789 ],
            [ "xyz", 789 ]
    ]</pre>
                        <p>The default visibility for a child row depends on its parent. If the parent row was set to hidden then the child row will still be added to the parent, but will be hidden as well.</p>
                        <p>If a parent row cannot be found for the children, those child rows will be ignored. If multiple parent rows exist for a given child row, the result is undefined.</p>
                    </section>
                    <section id="get-dataset">
                        <h3>Get dataset</h3>
                        <p>Visible dataset rows can be retrieved for use via the <code>getDataset</code> method.</p>
                        <pre>
    var dataset = [
        [ "column_a", "column_b", "column_c" ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ];

    var dw = new DataWorker(dataset);
    var records;

    dw.getDataset(function (result) { records = result; });</pre>
                        <p>The following is the contents of <code>records</code>:</p>
                        <pre>
    [
        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ]</pre>
                        <p>The <code>getDataset</code> method can also grab only specified rows:</p>
                        <pre>
    dw.getDataset(function (result) { records = result; }, "column_a", "column_b");</pre>
                        <p>The following would be the contents of <code>records</code>:</p>
                        <pre>
    [
        [ "apple",      "violin" ],
        [ "cat",        "tissue" ],
        [ "banana",      "piano" ],
        [ "gummy",       "power" ]
    ]</pre>
                        <p>Note that the following does the same thing as the preceding sample:</p>
                        <pre>
    dw.getDataset(
        function (result) { records = result; },
        [ "column_a", "column_b" ]
    );</pre>
                    </section>
                    <section id="get-rows">
                        <h3>Get rows</h3>
                        <p>Another function to fetch rows is <code>getRows</code>. This function works the same as <code>getDataset</code> except that it allows for a range of rows</p>
                        <p>If called with just the callback function, <code>getRows</code> will get all rows. The next two arguments are the start and end of the range. If unspecified, they are the start and end of the dataset. These arguments are 0-based, so a dataset with 15 rows will have rows 0 - 14. If a number larger than the last row is used DataWorker will simply return anything in the range <i>up to</i> (and including) the last row.</p>
                        <p>Like <code>getDataset</code>, <code>getRows</code> may also specify the columns. All of the following calls to getRows are valid examples:</p>
                        <pre>
    var callback = function (rows) { /* Do something */ };

    dw.getRows(callback);
    dw.getRows(callback, 5);
    dw.getRows(callback, undefined, 10);
    dw.getRows(callback, 5, 10);
    dw.getRows(callback, 5, 10, "column_a", "column_b");
    dw.getRows(callback, 5, 10, [ "column_a", "column_b" ]);
    dw.getRows(callback, undefined, undefined, [ "column_a", "column_b" ]);</pre>
                    </section>
                    <section id="get-hashed-rows">
                        <h3>Get hashed rows</h3>
                        <p>The <code>getHashedRows</code> function makes it possible to get records as a hash with the column names instead of as a simple array. It works exactly the same as <code>getRows</code> but returns the data in a different format. In the following example</p>
                        <pre>
    var dataset = [
        [ "column_a", "column_b", "column_c" ],

        [ "apple",      "violin",    "music" ],
        [ "cat",        "tissue",      "dog" ],
        [ "banana",      "piano",      "gum" ],
        [ "gummy",       "power",     "star" ]
    ];

    var dw = new DataWorker(dataset);
    var records;

    dw.getHashedRows(function (result) { records = result; });</pre>
                        <p>the contents of <code>records</code> will be:</p>
                        <pre>
    [
        {
            "column_a": "apple",
            "column_b": "violin",
            "column_c": "music"
        },
        {
            "column_a": "cat",
            "column_b": "tissue",
            "column_c": "dog"
        },
        {
            "column_a": "banana",
            "column_b": "piano",
            "column_c": "gum"
        },
        {
            "column_a": "gummy",
            "column_b": "power",
            "column_c": "star"
        }
    ]</pre>
                    </section>
                    <section id="get-columns">
                        <h3>Get columns</h3>
                        <p>The <code>getColumns</code> method is used to get the visible columns of the dataset:</p>
                        <pre>
    dw.getColumns(function (columns) {
        visibleColumns = columns;
    });</pre>
                        <p>Use <code>getAllColumns</code> to retrieve both visible and non-visible columns.</p>
                    </section>
                    <section id="get-columns-and-records">
                        <h3>Get columns and records</h3>
                        <p>Visible columns may be retrieved simultaneously with visible records with <code>getColumnsAndRecords</code>.</p>
                        <pre>
    dw.getColumnsAndRecords(function (columns, records) {
        // Do something.
    });</pre>
                        <p>Columns will be given as a dictionary with the <code>columnName</code> as the key and its properties (also in a dictionary) as the value.</p>
                        <p>Records will be returned the same as in <code>getDataset</code>.</p>
                    </section>
                    <section id="get-number-of-records">
                        <h3>Get number of records</h3>
                        <h5>Get number of records</h5>
                        <p>The <code>getNumberOfRecords</code> returns the number of visible rows currently in the dataset:</p>
                        <pre>
    dw.getNumberOfRecords(function (num) {
        numberOfRows = num;
    });</pre>
                        <p>Note that for streaming datasets, this value will be the current number of rows it has (and not the total number of rows expected). Use <code>getExpectedNumberOfRecords</code> to determine the total number of rows in a streaming dataset.</p>
                        <h5>Get expected number of records</h5>
                        <p>The <code>getExpectedNumberOfRecords</code> method returns the expected number of records in a streaming dataset.</p>
                        <pre>
    dw.getExpectedNumberOfRecords(function (num) {
        expectedNumberOfRows = num;
    });</pre>
                    </section>
                    <section id="get-distinct">
                        <h3>Get distinct</h3>
                        <h5>Get distinct consecutive rows</h5>
                        <p>Distinct rows can be retrieved using <code>getDistinctConsecutiveRows</code>. The function takes a <code>callback</code> and <code>columnName</code> as its parameters:</p>
                        <pre>
    function doSomethingInteresting(records) { }
    dw.getDistinctConsecutiveRows(doSomethingInteresting, "column_a");</pre>
                        <p>The value passed into the callback is an array of records. Each record contains three values: <code>value</code> of the column, <code>startRow</code> of that value, and <code>endRow</code> of that value.</p>
                        <p>If values are repeated again later, but not consecutively, another record will exist in the results. For example, with the following dataset:</p>
                        <pre>
    [
        [ "column_a", "column_b" ]

        [ "abc",      "123"      ],
        [ "abc",      "456"      ],
        [ "abc",      "789"      ],
        [ "def",      "123"      ],
        [ "ghi",      "123"      ],
        [ "ghi",      "456"      ],
        [ "def",      "456"      ],
        [ "def",      "789"      ]
    ]</pre>
                        <p>the function <code>getDistinctConsecutiveRows</code> will pass the following <code>records</code> into the callback as a sole parameter if "column_a" were passed in as <code>columnName</code>:</p>
                        <pre>
    [
        [ "abc", 0, 2 ],
        [ "def", 3, 3 ],
        [ "ghi", 4, 5 ],
        [ "def", 6, 7 ]
    ]</pre>
                        <p>but if "column_b" were passed in as <code>columnName</code> then the results would be:</p>
                        <pre>
    [
        [ "123", 0, 0 ],
        [ "456", 1, 1 ],
        [ "789", 2, 2 ],
        [ "123", 3, 4 ],
        [ "456", 5, 6 ],
        [ "789", 7, 7 ]
    ]</pre>
                        <p>The number of records returned will always be equal to or less than the number of records in the original dataset.</p>
                    </section>
                    <section id="pagination">
                        <h3>Pagination</h3>
                        <p>Pagination eases incremental of the records. The following sets DataWorker to display 10 rows per page</p>
                        <pre>
    dw.paginate(10);</pre>
                        <h5>Get next page</h5>
                        <p>Now you may grab the next 10 rows using the <code>getNextPage</code> method:</p>
                        <pre>
    var next10Rows, currentPage;

    dw.getNextPage(function (result, pageNumber) {
        next10Rows = result;
        currentPage = pageNumber;
    });</pre>
                        <p>The callback will provide the requested rows as well as the current page number.</p>
                        <p>The pagination system will not let you change to a page outside of the dataset. Grabbing the next page when you're on the last page will still return the last page.</p>
                        <h5>Get previous page</h5>
                        <p>The previous 10 rows can be grabbed using the <code>getPreviousPage</code> method:</p>
                        <pre>
    var previous10Rows, currentPage;

    dw.getPreviousPage(function (result, pageNumber) {
        previous10Rows = result;
        currentPage = pageNumber;
    });</pre>
                        <p>Grabbing a previous page from the 1st page will simply return the 1st page again.</p>
                        <h5>Get page</h5>
                        <p>You may jump to a specific page using the <code>getPage</code> method. The following grabs page 4:</p>
                        <pre>
    var page, currentPage;

    dw.getPage(function (result, pageNumber) {
        page = result;
        currentPage = pageNumber; // pageNumber == 4
    }, 4);</pre>
                        <p>Note that this also sets your current page to the page you grab.</p>
                        <h5>Ask for specific columns</h5>
                        <p>The previous three functions (<code>getNextPage</code>, <code>getPreviousPage</code>, and <code>getPage</code>) can all take extra arguments defining which columns to return. This will allow you to get a reduced dataset or specify columns that would normally be hidden. The columns can be defined as additional names, or as an array of names. The following are both valid:</p>
                        <pre>
    var callback = function (result, pageNumber) { /* Do something */ };

    dw.getNextPage(callback, "column_a", "column_b");
    dw.getNextPage(callback, [ "column_b", "column_c" ]);</pre>
                        <h5>Set page</h5>
                        <p>Use the <code>setPage</code> method to set a new current page. Attempting to set the page to 0 or a negative number will set the page to page 1. Setting to a page past the max number of current pages will set the page to the last page. The following sets your current page to page 4:</p>
                        <pre>
    dw.setPage(4);</pre>
                        <h5>Get number of pages</h5>
                        <p>Use the <code>getNumberOfPages</code> method to get the total number of pages in the dataset with the current pagination. Note that this is also the same as the last page in the dataset.</p>
                        <pre>
    var lastPage;

    dw.getNumberOfPages(function (totalNumberOfPages) {
        lastPage = totalNumberOfPages;
    });</pre>
                    </section>
                    <section id="partition">
                        <h3>Partition</h3>
                        <p>DataWorker can partition its dataset into multiple smaller datasets. The partitioned datasets can be retrieved afterwards using their partition key(s). The following partitions the dataset by the contents of <code>column_a</code> and uses the <code>getPartitioned</code> method to push each partition onto the <code>partitioned</code> array:</p>
                        <pre>
    var partitioned = [];

    dw.partition("column_a");

    dw.getPartitionKeys().forEach(function (key) {
        dw.getPartitioned(function (result) { partitioned.push(result); }, key);
    });</pre>
                        <p>They <code>getPartitioned</code> method returns an array of records.</code>
                        <p>You may also partition by multiple keys:</p>
                        <pre>
    dw.partition("column_a", "column_b");</pre>
                        <p>The following does the same thing:</p>
                        <pre>
    dw.partition([ "column_a", "column_b" ]);</pre>
                    </section>
                    <section id="render">
                        <h3>Render</h3>
                        <p>The <code>render</code> method allows you to pass DataWorker a function to render the dataset. When <code>render</code> is called without arguments, DataWorker will call the rendering function that the user passed in, or do nothing if the user has not set a rendering function.</p>
                        <pre>
    dw.render(function () { /* code for rendering the dataset */ });

    /* Make some changes to the dataset. */

    dw.render(); // Renders the new dataset according to the user-defined function.</pre>
                    </section>
                </div>
            </div>
        </div>
    </body>
</html>
